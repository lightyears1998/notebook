# 数据结构

## Chpater 1 绪论

数据结构研究的数据通常是非数值类数据。**研究问题的一般方法**是抽象、设计算法、编程。

### 数据的相关定义

1. *数据* 客观事物的符号表示，能输入计算机进行处理
2. *数据元素* *Data Element* 数据的基本单位
3. *数据项* *Data Item* 组成数据元素的、独立的、不可分割的基本单位
4. *数据对象* *Data Object* 同性质的数据的集合

### 数据的结构

1. 逻辑结构 数据的内在联系，与数据的储存结构无关
    1. 集合结构
    2. 线性结构
    3. 树结构
    4. 图结构
2. 存储结构
    1. 顺序存储结构
    2. 链式存储结构

### 抽象数据类型 ADT, Abstract Data Type

1. 数据对象 `D`
2. 数据对象上关系的集合 `S`
3. 对数据对象的基本操作的集合 `P`

### 算法 Algorithm

有穷性、确定性、可行性、可选输入、至少一个输出。

- **大O记号** 来自*数量级*的英语*Order of Magnitude*，描述函数数量级的渐进上界。数学上，若`T(n)`和`f(n)`是定义在`Z⁺`上的两个函数。则`T(n)=O(f(n))`表示存在正的常数`C`和`n₀`，使得当`n≥n₀`时都满足`0≤T(n)≤Cf(n)`。即函数`T(n)`和`f(n)`具有相同的增长趋势，且`T(n)`的增长至多趋向于函数`f(n)`的增长。
- **最好、最坏和平均时间复杂度** 人们更关心平均和最坏条件下的时间复杂度。平均时间复杂度一般不好估计，通常只讨论最坏条件下的时间复杂度。

### 算法的描述语言

相似于C语言，注意成组赋值`(a, b, c) = (v1, v2, v3)`和结构赋值`struct some = { v1, v2, v3}`，以及交换赋值`a <-> b`等补充语法。

## Chapter 1 线性表

1. 顺序表
2. 线性链表
3. 循环链表 具有合并速度上的优势
4. 双向链表

## Chapter 2 栈和队列

队列

1. 链式表示 链队列
2. 顺序表示 循环队列

栈

1. 顺序栈
2. 链栈

### 典型问题

1. 带优先级的括号匹配
2. 背包问题
3. 表达式的计算
    1. 后缀表达式
    2. 前缀表达式
    3. 中缀表达式

## Chapter 3 串

空串`"\0"`、空格串`" "`。

定长顺序储存表示（下标0储存字符串长度）、堆分配储存表示（结构体字段储存字符串长度）和块链储存表示（类似链表）。

### 模式匹配算法

1. 朴素的暴风算法 Brute-Force
2. KMP算法

关键：寻找最大的n，使得长度为n的字符串前缀和后缀相同。

```cpp
// 字符串采用定长顺序表示

// 返回主串str中第一个与模式串匹配的下标位置；如无匹配，返回0
int kmp(string str, string tmp)
{
    int i = 1, j = 1;
    while (i <= str[0] && j <= tmp[0]) {
        if (j == 0 || str[i] == str[j]) { ++i, ++j; }
        else j = next[j];
    }
    return 0;
}

// 计算next数组
// next[j] == 0表示下一次匹配应该从主串的第i+1位与模式串的第1位开始
// next[j] != 0表示下一次匹配应该从主串的第i位与模式串的第next[j]位开始
void next(string tmp)
{
    int i = 1, j = 0; next[1] = 0;
    while (i < tmp[0]) {
        if (j == 0 || tmp[i] == tmp[j]) { ++i, ++j, next[i] = j; }
        else j = next[j];
    }
}

// 修正的next算法
// 解决形如此类的next问题
// j        | 1 2 3 4 5
// template | a a a a b
// next     | 0 1 2 3 4
// next-fix | 0 0 0 0 4
void next(string tmp)
{
    int i = 1, j = 0; next[1] = 0;
    while (i < tmp[0]) {
        if (j == 0 || tmp[i] == tmp[j]) {
            ++i, ++j;
            if (tmp[i] != tmp[j]) next[i] = j;
            else next[i] = next[j];
        }
        else j = next[j];
    }
}
```
