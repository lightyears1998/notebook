# 数据结构

## Chpater 1 绪论

数据结构研究的数据通常是非数值类数据。**研究问题的一般方法**是抽象、设计算法、编程。

### 数据的相关定义

1. *数据* 客观事物的符号表示，能输入计算机进行处理
2. *数据元素* *Data Element* 数据的基本单位
3. *数据项* *Data Item* 组成数据元素的、独立的、不可分割的基本单位
4. *数据对象* *Data Object* 同性质的数据的集合

这里，数据元素（基本单位）包含了数据项（最小单位），可以通过`element`比`item`长来记忆。

### 数据的结构

1. 逻辑结构 可分为线性结构和非线性结构，表示数据的内在联系，与数据的储存结构无关
    1. 集合结构
    2. 线性结构
    3. 树结构
    4. 图结构
2. 存储结构
    1. 顺序存储结构
    2. 链式存储结构

### 抽象数据类型 ADT, Abstract Data Type

1. 数据对象 `D`
2. 数据对象上关系的集合 `S`
3. 对数据对象的基本操作的集合 `P`

### 算法 Algorithm

有穷性、确定性、可行性、可选输入、至少一个输出。

- **大O记号** 来自*数量级*的英语*Order of Magnitude*，描述函数数量级的渐进上界。数学上，若`T(n)`和`f(n)`是定义在`Z⁺`上的两个函数。则`T(n)=O(f(n))`表示存在正的常数`C`和`n₀`，使得当`n≥n₀`时都满足`0≤T(n)≤Cf(n)`。即函数`T(n)`和`f(n)`具有相同的增长趋势，且`T(n)`的增长至多趋向于函数`f(n)`的增长。
- **最好、最坏和平均时间复杂度** 人们更关心平均和最坏条件下的时间复杂度。平均时间复杂度一般不好估计，通常只讨论最坏条件下的时间复杂度。

### 算法的描述语言

相似于C语言，注意成组赋值`(a, b, c) = (v1, v2, v3)`和结构赋值`struct some = { v1, v2, v3}`，以及交换赋值`a <-> b`等补充语法。

## Chapter 1 线性表

1. 顺序表
2. 线性链表
3. 循环链表 具有合并速度上的优势
4. 双向链表

## Chapter 2 栈和队列

队列

1. 链式表示 链队列
2. 顺序表示 循环队列

栈

1. 顺序栈
2. 链栈

### 典型问题

1. 带优先级的括号匹配
2. 背包问题
3. 表达式的计算
    1. 后缀表达式
    2. 前缀表达式
    3. 中缀表达式

## Chapter 3 串

空串`"\0"`、空格串`" "`。

定长顺序储存表示（下标0储存字符串长度）、堆分配储存表示（结构体字段储存字符串长度）和块链储存表示（类似链表）。

### 模式匹配算法

1. 朴素的暴风算法 Brute-Force
2. KMP算法

关键：寻找最大的n，使得长度为n的字符串前缀和后缀相同。

```cpp
// 字符串采用定长顺序表示

// 返回主串str中第一个与模式串匹配的下标位置；如无匹配，返回0
int kmp(string str, string tmp)
{
    int i = 1, j = 1;
    while (i <= str[0] && j <= tmp[0]) {
        if (j == 0 || str[i] == str[j]) { ++i, ++j; }
        else j = next[j];
    }
    if (j > tmp[0]) { // 匹配成功
        return i - tmp[0];
    }
    return 0;
}

// 计算next数组
// next[j] == 0表示下一次匹配应该从主串的第i+1位与模式串的第1位开始
// next[j] != 0表示下一次匹配应该从主串的第i位与模式串的第next[j]位开始
void next(string tmp)
{
    int i = 1, j = 0; next[1] = 0;
    while (i < tmp[0]) {
        if (j == 0 || tmp[i] == tmp[j]) { ++i, ++j, next[i] = j; }
        else j = next[j];
    }
}

// 修正的next算法
// 解决形如此类的next问题
// j        | 1 2 3 4 5
// template | a a a a b
// next     | 0 1 2 3 4
// next-fix | 0 0 0 0 4
void next(string tmp)
{
    int i = 1, j = 0; next[1] = 0;
    while (i < tmp[0]) {
        if (j == 0 || tmp[i] == tmp[j]) {
            ++i, ++j;
            if (tmp[i] != tmp[j]) next[i] = j;
            else next[i] = next[j];
        }
        else j = next[j];
    }
}
```

## Chapter 4 数组和广义表

### 数组

1. （高维）数组的定义 只有修改而没有插入或者删除操作
2. 二维（高维）数组的顺序表示
    1. 行序主序方式 谁为主序，谁就在储存空间上连续；行为主序，则内存中第一块为第一行内存，第二块为第二行的内存……
    2. 列序主序方式
    3. 高维数组，通常假定高维为主序
3. 由基地址和下标确定元素在内存中的储存位置

    `Loc(j1, j2, ..., jn) = Loc(0, 0, ..., 0) + Σ[i=1, n]{CiJi}`（实际求值中累加次序从n到1，以便利用下面的递推公式）

    其中`Ji`为数组第i维的下标，`Bi`为数组第i维的大小，`Loc(j1, j2, ..., jn)`为对应下标的数组元素在寄存器中的位置。
    `Cn = L`，为单位数组元素在内存空间中占据的大小，`C_{i-1} = Ci * Bi`

### 数组的应用：矩阵的压缩储存

特殊的矩阵类型

1. 对称矩阵
2. 上/下三角矩阵
3. 对角矩阵

### 广义表

1. 广义表的定义
2. 广义表的储存结构

### 广义表的应用

1. m元多项式的表示
2. 广义表的递归算法
